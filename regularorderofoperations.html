<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <title>RIPAL: Responsive and Intuitive Parsing for the Analysis of Language</title>
    <link href="styles/styles.css" rel="stylesheet" type="text/css" media="all"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
  </head>
  <body>
    <h1>RIPAL: Responsive and Intuitive Parsing for the Analysis of Language</h1>
    <h2>Pages</h2>
    <nav aria-label="Pages">
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="theory.html">Theory</a></li>
        <li><a href="contact.html">Contact</a></li>
      </ul>
    </nav>
    <h2>Order of operations in regular expressions</h2>
    <div class="section">
      <h3>Background</h3>
      <p>Now that we're exploring the operators of Kleene closure, concatenation and union over regular expressions, we should define the order of precedence of these operators. This is important in order to illustrate a singular meaning for any regular expression.</p>
    </div>
    <div class="section">
      <h3>Kleene closure vs. concatenation</h3>
      <p><em>Example</em></p>
      <p>&Sigma; = {a, b}</p>
      <p>R = ab<sup>*</sup></p>
      <p>Without specifying operator precedence, this could be interpretated as (using parentheses to denote higher precedence):</p>
      <ol>
        <li>a(b<sup>*</sup>) OR</li>
        <li>(ab)<sup>*</sup></li>
      </ol>
      <p>By convention, we state that the first interpretation is correct.</p>
      <p>As a result, our regular expression describes the strings</p>
      <ol>
        <li>a</li>
        <li>ab</li>
        <li>abb</li>
        <li>...</li>
      </ol>
      <p>but not</p>
      <ol>
        <li>&epsilon;</li>
        <li>abab</li>
        <li>ababab</li>
        <li>...</li>
      </ol>
      <p>Note that the string ab would be described by either interpretation.</p>
    </div>
    <div class="section">
      <h3>Concatenation vs union</h3>
      <div class="subsection example">
        <p><em>Example</em></p>
        <p>&Sigma; = {a, b, c}</p>
        <p>R = ab &cup; c</p>
        <p>Without specifying operator precedence, this could be interpreted as:</p>
        <ol>
          <li>(ab) &cup; c OR</li>
          <li>a(b &cup; c)</li>
        </ol>
        <p>By convention, we state that the first interpretation is correct.</p>
        <p>As a result, our regular expression describes the strings</p>
        <ol>
          <li>ab</li>
          <li>c</li>
        </ol>
        <p>but not</p>
        <ol>
          <li>ac</li>
        </ol>
        <p>Note that the string ab would be described by either interpretation.</p>
      </div>
    </div>
    <div class="section">
      <h3>Parentheses</h3>
      <p>A matching par of parentheses can be used, as shown in interpretations above, to enforce a certain order of precedence when the default precedence rules don't suffice.</p>
      <div class="subsection example">
        <p><em>Example</em></p>
        <p>&Sigma; = {a, b}</p>
        <p>R = (ab)<sup>*</sup></p>
        <p>This regular expression matches the language:</p>
        <p>L = {&epsilon;, ab, abab, ababab, ...}</p>
      </div>
      <div class="subsection example">
        <p><em>Example</em></p>
        <p>&Sigma; = {a, b, c}</p>
        <p>R = a(b &cup; c)</p>
        <p>This regular expression matches the language:</p>
        <p>L = {ab, ac}</p>
      </div>
    </div>
    <hr/>
    <p>GitHub Repository: <a href="https://github.com/bprollinson/ripal">https://github.com/bprollinson/ripal</a></p>
    <p>Copyright &copy; 2017 Brendan Rollinson-Lorimer</p>
  </body>
</html>
