<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <title>RIPAL: Responsive and Intuitive Parsing for the Analysis of Language</title>
    <link href="styles/styles.css" rel="stylesheet" type="text/css" media="all"/>
  </head>
  <body>
    <h1>RIPAL: Responsive and Intuitive Parsing for the Analysis of Language</h1>
    <h2>Pages</h2>
    <nav aria-label="Pages">
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="theory.html">Theory</a></li>
        <li><a href="contact.html">Contact</a></li>
      </ul>
    </nav>
    <h2>Converting an NFA to a DFA</h2>
    <p><b>Background</b></p>
    <p>We've seen the process of converting and &epsilon;-NFA to an NFA. This process will be extremely helpful in converting regular expressions into a state machine that's easy to use. However, NFAs may still have multiple transitions for the same input symbol from the same state, which makes the recognition process difficult. In this section, we'll demonstrate how to convert an NFA into a DFA in order to provide a simpler recognition mechanism.</p>
    <p><b>Example</b></p>
    <p>The following NFA contains multiple transitions for the same input symbol from the same state:</p>
    <img src="assets/examplemultipletransitionssamesymbol.png" alt="NFA with multiple transitions for the same state and symbol. This NFA contains 4 states - s0, s1, s2 and s3. s0 transitions to s1 on input symbol a. s1 transitions to s2 and s3 on input symbol b. s2 is accepting."/>
    <p>This NFA recognizes the language L = {ab}. When parsing the string ab, after we encounter symbol b in state s<sub>1</sub>, we can choose to transition to state s<sub>2</sub> or s<sub>3</sub>. Since we are only looking for a single path to an accepting state, we would choose to transition to s<sub>2</sub> and accept the string.</p>
    <p>As a result, this NFA is equivalent to the following DFA:</p>
    <img src="assets/exampledfareduced.png" alt="Simplified DFA. This DFA contains 3 states - s0, s1 and s2. s0 transitions to s1 on input symbol a. s1 transitions to s2 on input symbol b. s2 is accepting."/>
    <p><b>More complex example</b></p>
    <p>The following NFA is a more complex example of an NFA that can be reduced:</p>
    <img src="assets/examplecomplexmultipletransitionssamesymbol.png" alt="Complex NFA with multiple transitions for the same symbol and state. This NFA contains 6 states - s0 through s5. s0 transitions to s1 on input symbol a. s1 transitions to s0 and s3 on input symbol b. s1 transitions to s2 on input symbol c. s3 transitions to s4 on input symbol a. s4 transitions to s5 on input symbol c. s2 is accepting."/>
    <p>Here, it's less clear how to reduce this to a DFA.</p>
    <p>Now, consider the transitions from s<sub>1</sub>	for input symbol b. The possible set of next states is: {s<sub>0</sub>, s<sub>3</sub>}.</p>
    <p>Since we only need to find a single path for a certain input string to an accepting state, we would continue this process. For example, if the next input symbol is a, the possible set of next states is: {s<sub>1</sub>, s<sub>4</sub>}.</p>
    <p><b>Reduction process</b></p>
    <p>To outline the reduction process, for our set of states S, we must consider consider the power set of S.</p>
    <p>We know that S = {s<sub>0</sub>, s<sub>1</sub>, ..., s<sub>n - 1</sub>}.</p>
    <p>P(S) = {{}, {s<sub>0</sub>}, ..., {s<sub>n - 1</sub>}, {s<sub>0</sub>, s<sub>1</sub>}, {s<sub>0</sub>, s<sub>2</sub>}, ..., {s<sub>n - 2</sub>, s<sub>n - 1</sub>}, {s<sub>0</sub>, s<sub>1</sub>, s<sub>2</sub>}, ..., {s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>n - 1</sub>}}</p>
    <p>Informally, the power set of S is the set containg all possible subsets of S.</p>
    <p>Since, as illustated above, we need to consider combinations of possible states, we will construct a new set of states in our DFA which maps to some combination of states from our DFA, which is some element of the power set of (S).</p>
    <p>Our DFA's start state corresponds to the element {s<sub>0</sub>} from P(S).</p>
    <p>Then, for each input symbol corresponding to a transition in any state from NFA, we create a new DFA state corresponding to the set of all states reachable from that symbol (or reuse the DFA state corresponding to that combination if one exists) and add the corresponding transition.</p>
    <p>We set our new DFA state to accepting if at least on corresponding NFA is accepting.</p>
    <p><b>More complex example reduced</b></p>
    <p>Following the instruction from above, our complex NFA can can be reduced to the following DFA:</p>
    <img src="assets/examplecomplexdfareduced.png" alt="Simplified DFA. This DFA contains 6 states, each of which represents some set of states from the DFA. State with set s0 transitions to state with set s1 on input symbol a. State with set s1 transitions to state with set s2 on input symbol c. State with set s1 transitions to state with set s0, s3 on input symbol b. State with set s0, s3 transitions to state with set s1, s4 on input symbol a. State with set s1, s4 transitions to state with set s2, s5 on input symbol c. All new states containing s2 are accepting."/>
    <p>Finally, we can re-label the states as follows:</p>
    <img src="assets/examplecomplexdfareducedrelabelled.png" alt="Simplified DFA relabelled This dfa contains 6 states - s0 through s5. s0 transitions to s1 in input symbol a. s1 transitions to s2 on input symbol c. s1 transitions to s3 on input symbol b. s3 transitions to s4 on input symbol a. s4 transitions to s5 on input symbol c. s2 and s5 are accepting."/>
    <p>Note that the two states whose state set from the NFA contain s<sub>2</sub> are marked as final statse.</p>
    <p><b>Conclustion</b></p>
    <p>In conclusion, we now have a process to convert an NFA to a DFA. Using Thompons's construction along with the &epsilon;-NFA to NFA conversion process, we can now convert regular expressions in to NFAs for recognition.</p>
    <hr/>
    <p>GitHub Repository: <a href="https://github.com/bprollinson/ripal">https://github.com/bprollinson/ripal</a></p>
    <p>Copyright &copy; 2017 Brendan Rollinson-Lorimer</p>
  </body>
</html>
