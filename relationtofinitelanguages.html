<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <title>RIPAL: Responsive and Intuitive Parsing for the Analysis of Language</title>
    <link href="styles/styles.css" rel="stylesheet" type="text/css" media="all"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
  </head>
  <body>
    <h1>RIPAL: Responsive and Intuitive Parsing for the Analysis of Language</h1>
    <h2>Pages</h2>
    <nav aria-label="Pages">
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="theory.html">Theory</a></li>
        <li><a href="contact.html">Contact</a></li>
      </ul>
    </nav>
    <h2>Relation to finite languages</h2>
    <div class="section">
      <h3>Background</h3>
      <p>We now have a good understanding of finite languages and the basic setup of regular languages via regular expressions.</p>
      <p>But how do they relate to eachother?</p>
    </div>
    <div class="section">
      <h3>All finite languages are regular</h3>
      <p>Let's say we have a finite language L with the following specification:</p>
      <p>L = {s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>n</sub>}</p>
      <p>We can construct a regular expression for this language as follows:</p>
      <p>R = s<sub>1</sub> &cup; s<sub>2</sub> &cup; ... &cup; s<sub>n</sub></p>
      <p>This regular expression matches all of the strings in L.</p>
    </div>
    <div class="section">
      <h3>Special case: The empty language</h3>
      <p>We know that the following regular expression:</p>
      <p>R = &oslash;</p>
      <p>matches the empty language. This language is both regular and finite because it contains a fixed number of strings.</p>
    </div>
    <div class="section">
      <h3>Finite-ness of a regular expression</h3>
        <p>Any regular expression that does not contain the Kleene closure operator always represents a finite language.</p>
        <p>The concatenation and union operators, when applied to a finite set of symbols, always results in a finite set of strings. Furthermore, the process of enumerating the strings in the language is fairly straightforward.</p>
        <div class="subsection example">
        <p><em>Example</em></p>
        <p>&Sigma; = {a, b, c, d, e}</p>
        <div class="derivation">R = a(b &cup; c(d &cup; e))
  = a(b &cup; cd &cup; ce)
  = ab &cup; acd &cup; ace</div>
        <p>From this, we can determine that L = {ab, acd, ace}.</p>
      </div>
      <p>However, the Kleene closure operator is often used to specify infinite languages. Any non-empty inner expression that has the Kleene closure operator applied to it and then optionally concatenated or combined via union with any other expression will result in an infinite language.</p>
      <p>Practically speaking, any Kleene closure operator on anything other than &epsilon; or (<sup>n</sup>&epsilon;)<sup>n</sup> will result in an expression represeting an infinite language.</p>
      <div class="subsection example">
        <p><em>Example</em></p>
        <p>&Sigma; = {a, b, c}<p>
        <div class="derivation">R = &epsilon;<sup>*</sup>a(b &cup; c)
  = a(b &cup; c)
  = ab &cup; ac</div>
        <p>Clearly, L = {ab, ac}, which is finite.</p>
      </div>
      <div class="subsection example">
        <p><em>Example</em></p>
        <p>&Sigma; = {a, b}</p>
        <div class="derivation">R = a(b &cup; c<sup>*</sup>)
  = ab &cup; ac<sup>*</sup></div>
        <p>L = {ab, a, ac, acc, accc, ...}, which is inifite.</p>
      </div>
    </div>
    <hr/>
    <p>GitHub Repository: <a href="https://github.com/bprollinson/ripal">https://github.com/bprollinson/ripal</a></p>
    <p>Copyright &copy; 2017 Brendan Rollinson-Lorimer</p>
  </body>
</html>
